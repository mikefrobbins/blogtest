---
ID: 15258
post_title: >
  PowerShell and the Nimble Storage REST
  API
author: Mike F Robbins
post_excerpt: ""
layout: post
permalink: >
  https://mikefrobbins.com/2017/06/01/powershell-and-the-nimble-storage-rest-api/
published: true
post_date: 2017-06-01 07:30:55
---
If you read my previous blog article on "<a href="http://mikefrobbins.com/2017/05/25/powershell-function-to-determine-the-installed-vss-providers/" target="_blank" rel="noopener noreferrer">PowerShell Function to Determine the Installed VSS Providers</a>" then you're already aware that I recently migrated one of my customers to a Nimble Storage Area Network.

While Nimble does have a PowerShell module and it's decent, I wanted to see how difficult it is to work with their REST API directly with PowerShell. Their REST API documentation also seems to be decent.

<span style="color: #ff0000;"><strong> Note: All of the functions shown in this blog article are a proof of concept and should be thoroughly tested before attempting to use them in a production environment.</strong></span>

First of all, you need to connect to the Nimble SAN group so I wrote a function for that:
<pre class="lang:ps decode:true">#Requires -Version 4.0 -Module TunableSSLValidator
function Connect-MrNSGroup {

&lt;#
.SYNOPSIS
    Connects to a Nimble SAN.
 
.DESCRIPTION
    Connect-MrNSGroup is an advanced function that provides the initial connection to a Nimble SAN
    so that other subsequent commands can be run without having to each authenticate individually.
    The TunableSSLValidator module is required since Nimble uses an untrusted SSL certificate. It
    can be found on GitHub: https://github.com/Jaykul/Tunable-SSL-Validator
 
.PARAMETER Group
    The DNS name or IP address of the Nimble group.

.PARAMETER Port
    The port number for the Nimble REST API. The default value is 5392. This parameter is hidden and
    provided only as a means to easily change the port number if the API ever changes.

.PARAMETER Credential
    Specifies a user account that has permission to perform this action. Type a user name, such as User01
     or enter a PSCredential object, such as one generated by the Get-Credential cmdlet. If you type a
     user name, this function prompts you for a password.
 
.EXAMPLE
     Connect-MrNSGroup -Group nimblegroup.yourdns.local -Credential (Get-Credential)

.EXAMPLE
     Connect-MrNSGroup -Group 192.168.1.50 -Credential (Get-Credential)
 
.INPUTS
    None
 
.OUTPUTS
    None
 
.NOTES
    Author:  Mike F Robbins
    Website: http://mikefrobbins.com
    Twitter: @mikefrobbins
#&gt;

    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]$Group,

        [Parameter(DontShow)]
        [ValidateNotNullOrEmpty()]
        [int]$Port = 5392,

        [Parameter(Mandatory)]
        [System.Management.Automation.Credential()]$Credential
    )    

    $Uri = "https://$($Group):$($Port)"
    
    $Script:tokenData = TunableSSLValidator\Invoke-RestMethod -Uri "$Uri/v1/tokens" -InSecure -Method Post -Body ((@{data = @{username = $Credential.UserName;password = $Credential.GetNetworkCredential().password}}) | ConvertTo-Json)
    $Script:RestVersion = (TunableSSLValidator\Invoke-RestMethod -Uri "$Uri/versions" -Insecure).data.name
    $Script:session_token = $tokenData.data.session_token
    $Script:array = $Group
}</pre>
I'm not a big fan of globally scoping variables unless absolutely necessary, but in this scenario unless you want to authenticate with every command, it does seem to be necessary. Their SAN uses a self-signed SSL certificate and I found that fellow Microsoft MVP <a href="https://twitter.com/Jaykul" target="_blank" rel="noopener noreferrer">Joel Bennett</a> had written a PowerShell module named <a href="https://github.com/Jaykul/Tunable-SSL-Validator" target="_blank" rel="noopener noreferrer">TunableSSLValidator</a> that adds an <em>Insecure</em> parameter to <em>Invoke-RestMethod</em> which kept me from having to worry about writing the code to handle it myself.

<em>Update: Based on feedback from Joel Bennett, I changed the variable scoping from Global to Script to limit their access to only the module.</em>

While many examples you might find store things like the value for <em>Body</em> parameter in a variable, the password is decrypted and then transmitted using the SSL encryption so I didn't want the plain text password hanging around in a variable for however long I leave my current PowerShell session open so I decided to perform the decryption inline when that line of code is executed.

This next function gets the session tokens for users who are connected to the Nimble SAN group:
<pre class="lang:ps decode:true ">#Requires -Version 4.0 -Module TunableSSLValidator
function Get-MrNSToken {

&lt;#
.SYNOPSIS
    List user session tokens.
 
.DESCRIPTION
    Get-MrNSToken is an advanced function that lists user session tokens for the specified Nimble SAN.
    The TunableSSLValidator module is required since Nimble uses an untrusted SSL certificate. It can
    be found on GitHub: https://github.com/Jaykul/Tunable-SSL-Validator
 
.PARAMETER Group
    The DNS name or IP address of the Nimble group. The default is the group that you've already connected
    to using the Connect-MrNSGroup function.

.PARAMETER Port
    The port number for the Nimble REST API. The default value is 5392. This parameter is hidden and
    provided only as a means to easily change the port number if the API ever changes.
 
.EXAMPLE
     Get-NStoken

.INPUTS
    None
 
.OUTPUTS
    MrNS.Token
 
.NOTES
    Author:  Mike F Robbins
    Website: http://mikefrobbins.com
    Twitter: @mikefrobbins
#&gt;

    [CmdletBinding()]
    param (
        [Parameter(DontShow)]
        [ValidateNotNullOrEmpty()]
        [string]$Group = $array,

        [Parameter(DontShow)]
        [ValidateNotNullOrEmpty()]
        [int]$Port = 5392
    )

    $Uri = "https://$($Group):$($Port)"

    $Header = @{'X-Auth-Token' = $session_token}

    $Tokens = TunableSSLValidator\Invoke-RestMethod -Uri "$Uri/v1/tokens" -Method Get -Header $Header -Insecure

    foreach ($Token in $Tokens.data.id){  
  
        $TokenUri = "$Uri/v1/tokens/$Token"

        $Result = (TunableSSLValidator\Invoke-RestMethod -Uri $TokenUri -Method Get -Header $header -Insecure).data
        $Result.PSTypeNames.Insert(0,'MrNS.Token')

        Write-Output $Result
    }  

}</pre>
I decided to go ahead and turn these functions into a module so it would be easier to add both custom formatting and custom types. One thing I've found is most SAN vendors simply give you everything back from the API. That ends up being an overwhelming amount of information so I decided to only return a few key properties in a table by default without having to hard code anything or pipe to format table. That's where the custom formatting comes into play. This .format.ps1xml file also includes custom formatting for the next function we'll look at.
<pre class="lang:ps decode:true ">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;Configuration&gt;
    &lt;ViewDefinitions&gt;
        &lt;View&gt;
            &lt;Name&gt;MrNS.Token&lt;/Name&gt;
            &lt;ViewSelectedBy&gt;
                &lt;TypeName&gt;MrNS.Token&lt;/TypeName&gt;
            &lt;/ViewSelectedBy&gt;
            &lt;TableControl&gt;
                &lt;TableHeaders&gt;
                     &lt;TableColumnHeader&gt;
                        &lt;Width&gt;12&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;                   
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;15&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;35&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;24&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;24&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                &lt;/TableHeaders&gt;
                &lt;TableRowEntries&gt;
                    &lt;TableRowEntry&gt;
                        &lt;TableColumnItems&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;UserName&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;Source_IP&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;Session_Token&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;CreateTime&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;ModifiedTime&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                        &lt;/TableColumnItems&gt;
                    &lt;/TableRowEntry&gt;
                 &lt;/TableRowEntries&gt;
            &lt;/TableControl&gt;
        &lt;/View&gt;
        &lt;View&gt;
            &lt;Name&gt;MrNS.Volume&lt;/Name&gt;
            &lt;ViewSelectedBy&gt;
                &lt;TypeName&gt;MrNS.Volume&lt;/TypeName&gt;
            &lt;/ViewSelectedBy&gt;
            &lt;TableControl&gt;
                &lt;TableHeaders&gt;
                     &lt;TableColumnHeader&gt;
                        &lt;Width&gt;25&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;                   
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;10&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;10&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;26&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;18&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                    &lt;TableColumnHeader&gt;
                        &lt;Width&gt;10&lt;/Width&gt;
                    &lt;/TableColumnHeader&gt;
                &lt;/TableHeaders&gt;
                &lt;TableRowEntries&gt;
                    &lt;TableRowEntry&gt;
                        &lt;TableColumnItems&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;Name&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;Size&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;vol_state&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;perfpolicy_name&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;thinly_provisioned&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                            &lt;TableColumnItem&gt;
                                &lt;PropertyName&gt;block_size&lt;/PropertyName&gt;
                            &lt;/TableColumnItem&gt;
                        &lt;/TableColumnItems&gt;
                    &lt;/TableRowEntry&gt;
                 &lt;/TableRowEntries&gt;
            &lt;/TableControl&gt;
        &lt;/View&gt;
    &lt;/ViewDefinitions&gt;
&lt;/Configuration&gt;</pre>
You could also add custom formatting so piping to <em>Format-List</em> would only return specific properties unless all properties were explicitly requested either with <em>Format-Table -Property *</em> or <em>Select-Object -Property *</em>. An example of how to write custom formatting for list views can be found in my blog article about "<a href="http://mikefrobbins.com/2015/08/30/my-solution-august-2015-powershell-scripting-games-puzzle/" target="_blank" rel="noopener noreferrer">My Solution: August 2015 PowerShell Scripting Games Puzzle</a>".

I also added a custom types file which adds a human readable date for the session token creation and modified time stamps. The value that the API returns is the number of seconds since January 1, 1970. The .types.ps1xml file simply adds a couple of script properties without having to manually add them to the function itself which seemed to be a cleaner solution.
<pre class="lang:ps decode:true">&lt;Types&gt;
    &lt;Type&gt;
      &lt;Name&gt;MrNS.Token&lt;/Name&gt;
      &lt;Members&gt;
        &lt;ScriptProperty&gt;
          &lt;Name&gt;CreateTime&lt;/Name&gt;
          &lt;GetScriptBlock&gt;
            (Get-Date -Date '1/1/1970').AddSeconds($this.creation_time)
          &lt;/GetScriptBlock&gt;
        &lt;/ScriptProperty&gt;
      &lt;/Members&gt;
    &lt;/Type&gt;
    &lt;Type&gt;
      &lt;Name&gt;MrNS.Token&lt;/Name&gt;
      &lt;Members&gt;
        &lt;ScriptProperty&gt;
          &lt;Name&gt;ModifiedTime&lt;/Name&gt;
          &lt;GetScriptBlock&gt;
            (Get-Date -Date '1/1/1970').AddSeconds($this.last_modified)
          &lt;/GetScriptBlock&gt;
        &lt;/ScriptProperty&gt;
      &lt;/Members&gt;
    &lt;/Type&gt;
&lt;/Types&gt;</pre>
To me, the really cool function is the one I wrote to retrieve a list of volumes:
<pre class="lang:ps decode:true ">#Requires -Version 4.0 -Module TunableSSLValidator
function Get-MrNSVolume {

&lt;#
.SYNOPSIS
    Retrieves information for volumes on a Nimble SAN.
 
.DESCRIPTION
    Get-MrNSVolume is an advanced function that retrieves information for volumes on a Nimble SAN.
    The TunableSSLValidator module is required since Nimble uses an untrusted SSL certificate. It can
    be found on GitHub: https://github.com/Jaykul/Tunable-SSL-Validator
 
.PARAMETER Group
    The DNS name or IP address of the Nimble group. The default is the group that you've already connected
    to using the Connect-MrNSGroup function.

.PARAMETER Port
    The port number for the Nimble REST API. The default value is 5392. This parameter is hidden and
    provided only as a means to easily change the port number if the API ever changes.
 
.PARAMETER Name
    Name of the volume.

.PARAMETER Id
    Identifier for the volume.
 
.EXAMPLE
     Get-MrNSVolume -Name Volume001

.EXAMPLE
     Get-MrNSVolume -Id '07204756105a0139c1000000000000000000000009'
 
.INPUTS
    None
 
.OUTPUTS
    MrNS.Volume
 
.NOTES
    Author:  Mike F Robbins
    Website: http://mikefrobbins.com
    Twitter: @mikefrobbins
#&gt;

    [CmdletBinding(DefaultParameterSetName='Name')]
    param (
        [Parameter(DontShow)]
        [ValidateNotNullOrEmpty()]
        [string]$Group = $array,

        [Parameter(DontShow)]
        [ValidateNotNullOrEmpty()]
        [int]$Port = 5392,

        [Parameter(ParameterSetName='Name')]
        [string]$Name,

        [Parameter(ParameterSetName='Id')]
        [string]$Id
    )

    $Uri = "https://$($Group):$($Port)"

    $Params = @{        
        Header = @{'X-Auth-Token' = $session_token}
        Method = 'Get'
        Insecure = $true
    }

    if ($PSBoundParameters.Name){
            
        $Params.Uri = "$Uri/v1/volumes?name=$Name"

    }
    elseif ($PSBoundParameters.Id) {
        
        $Params.Uri = "$Uri/v1/volumes?id=$Id"
    }
    else {

        $Params.Uri = "$Uri/v1/volumes"

    }    

    $Volumes = (TunableSSLValidator\Invoke-RestMethod @Params).data
            
    foreach ($Volume in $Volumes.id){  
  
        $Params.Uri = "$Uri/v1/volumes/$Volume"

        $Result = (TunableSSLValidator\Invoke-RestMethod @Params).data
        $Result.PSTypeNames.Insert(0,'MrNS.Volume')

        Write-Output $Result

    }

}</pre>
Do you see how splatting is used to dynamically build the commands and how it's used to reduce the amount of redundancy and minimize the amount of code you have to write?

The functions shown in this blog article are part of my MrNS PowerShell module which can be downloaded from <a href="https://github.com/mikefrobbins/Nimble" target="_blank" rel="noopener noreferrer">my Nimble repository on GitHub</a>.

µ